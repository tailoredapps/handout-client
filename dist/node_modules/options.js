'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = getOptions;

var _expandHomeDir = require('expand-home-dir');

var _expandHomeDir2 = _interopRequireDefault(_expandHomeDir);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _yargonaut = require('yargonaut');

var _yargonaut2 = _interopRequireDefault(_yargonaut);

var _yargs = require('yargs');

var _yargs2 = _interopRequireDefault(_yargs);

var _commands = require('commands');

var _commands2 = _interopRequireDefault(_commands);

var _output = require('output');

var _output2 = _interopRequireDefault(_output);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _opts = undefined;

var usage = _output.outputStyles.usage;
var cliArg = _output.outputStyles.cliArg;

var payloadModifiers = new Map([['user', function (payload) {
  var action = payload.action;
  var pubkey = payload.pubkey;

  if (action === 'remove') {
    return payload; // Nothing to modify when removing a user
  }

  if (!pubkey) {
    throw new Error('No public key file specified.');
  }

  // Okay to use sync method here, since this is a commandline client (i.e. blocking the event loop for a short time does not matter)
  return Object.assign({}, payload, { pubkey: _fs2.default.readFileSync((0, _expandHomeDir2.default)(pubkey), { encoding: 'utf8' }) });
}]]);

function registerOptions(_ref, parentOptions) {
  var command = _ref.command;
  var desc = _ref.desc;
  var usageStr = _ref.usageStr;
  var examples = _ref.examples;
  var options = _ref.options;

  _yargs2.default.command(command, desc, function (yargs) {
    yargs.options(Object.assign({}, options, parentOptions)).help('help').alias('help', 'h').usage('\n' + usage('USAGE') + ': $0 ' + usageStr);

    if (examples) {
      examples.forEach(function (_ref2) {
        var cli = _ref2.cli;
        var desc = _ref2.desc;
        return yargs.example('$0 ' + cli, desc);
      });
    }
  });
}

function getOptions() {
  if (_opts) {
    return _opts;
  }

  // Yes, the rc package could be used to handle this, but since it does much more than reading ~/.handoutrc I opted for a much simpler approach
  var rcpath = (0, _expandHomeDir2.default)('~/.handoutrc');

  var defaults = require('../../defaults.json');

  try {
    Object.assign(defaults, JSON.parse(_fs2.default.readFileSync(rcpath, { encoding: 'utf8' })));
    (0, _output2.default)('Using default values from ' + rcpath);
  } catch (e) {
    // No .handoutrc file found, moving on
    (0, _output2.default)('No ' + rcpath + ' file found');
  }

  _yargonaut2.default.style('cyan').style('yellow', 'required').errorsStyle('red.bold');

  _yargs2.default.help('help').alias('help', 'h').usage('\n' + usage('USAGE') + ': $0 ' + cliArg('command') + ' [options]').epilogue('To get a list of available options for each command, use "$0 ' + cliArg('command') + ' -h" (e.g. "$0 ' + cliArg('deploy') + ' -h")');

  var _getCommands = (0, _commands2.default)(defaults);

  var commands = _getCommands.commands;
  var globalOptions = _getCommands.globalOptions;

  commands.forEach(function (c) {
    return registerOptions(c, globalOptions);
  });

  var raw = _yargs2.default.argv;

  var _raw$_ = _slicedToArray(raw._, 1);

  var command = _raw$_[0];

  if (!command) {
    throw new Error('No command provided. Use -h to see available commands and options.');
  }

  _opts = {
    command: command
  };

  var payload = {};

  Object.keys(globalOptions).forEach(function (k) {
    return _opts[k] = raw[k];
  });

  var commandDefinition = commands.find(function (c) {
    return c.command === command;
  });

  if (commandDefinition.options) {
    Object.keys(commandDefinition.options).forEach(function (k) {
      return payload[k] = raw[k];
    });
  }

  _opts.payload = payloadModifiers.has(command) ? payloadModifiers.get(command)(payload) : payload;

  return _opts;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlX21vZHVsZXMvb3B0aW9ucy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7a0JBOEN3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXBDeEIsSUFBSSxpQkFBSjs7SUFFUTtJQUFPOztBQUVmLElBQU0sbUJBQW1CLElBQUksR0FBSixDQUFRLENBQy9CLENBQUUsTUFBRixFQUFVLFVBQVUsT0FBVixFQUFtQjtNQUNuQixTQUFtQixRQUFuQixPQURtQjtNQUNYLFNBQVcsUUFBWCxPQURXOztBQUczQixNQUFJLFdBQVcsUUFBWCxFQUFxQjtBQUN2QixXQUFPLE9BQVA7QUFEdUIsR0FBekI7O0FBSUEsTUFBSSxDQUFDLE1BQUQsRUFBUztBQUNYLFVBQU0sSUFBSSxLQUFKLENBQVUsK0JBQVYsQ0FBTixDQURXO0dBQWI7OztBQVAyQixTQVlwQixPQUFPLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLE9BQWxCLEVBQTJCLEVBQUMsUUFBUSxhQUFHLFlBQUgsQ0FBZ0IsNkJBQWMsTUFBZCxDQUFoQixFQUF1QyxFQUFFLFVBQVUsTUFBVixFQUF6QyxDQUFSLEVBQTVCLENBQVAsQ0FaMkI7Q0FBbkIsQ0FEcUIsQ0FBUixDQUFuQjs7QUFpQk4sU0FBUyxlQUFULE9BQTBFLGFBQTFFLEVBQXlGO01BQTdELHVCQUE2RDtNQUFwRCxpQkFBb0Q7TUFBOUMseUJBQThDO01BQXBDLHlCQUFvQztNQUExQix1QkFBMEI7O0FBQ3ZGLGtCQUNHLE9BREgsQ0FDVyxPQURYLEVBQ29CLElBRHBCLEVBQzBCLGlCQUFTO0FBQy9CLFVBQ0csT0FESCxDQUNXLE9BQU8sTUFBUCxDQUFjLEVBQWQsRUFBa0IsT0FBbEIsRUFBMkIsYUFBM0IsQ0FEWCxFQUVHLElBRkgsQ0FFUSxNQUZSLEVBR0csS0FISCxDQUdTLE1BSFQsRUFHaUIsR0FIakIsRUFJRyxLQUpILFFBSWMsTUFBTSxPQUFOLGNBQXNCLFFBSnBDLEVBRCtCOztBQU8vQixRQUFJLFFBQUosRUFBYztBQUNaLGVBQVMsT0FBVCxDQUFpQjtZQUFFO1lBQUs7ZUFBVSxNQUFNLE9BQU4sU0FBb0IsR0FBcEIsRUFBMkIsSUFBM0I7T0FBakIsQ0FBakIsQ0FEWTtLQUFkO0dBUHNCLENBRDFCLENBRHVGO0NBQXpGOztBQWVlLFNBQVMsVUFBVCxHQUF1QjtBQUNwQyxNQUFJLEtBQUosRUFBVztBQUNULFdBQU8sS0FBUCxDQURTO0dBQVg7OztBQURvQyxNQU05QixTQUFTLDZCQUFjLGNBQWQsQ0FBVCxDQU44Qjs7QUFRcEMsTUFBSSxXQUFXLFFBQVEscUJBQVIsQ0FBWCxDQVJnQzs7QUFVcEMsTUFBSTtBQUNGLFdBQU8sTUFBUCxDQUFjLFFBQWQsRUFBd0IsS0FBSyxLQUFMLENBQVcsYUFBRyxZQUFILENBQWdCLE1BQWhCLEVBQXdCLEVBQUUsVUFBVSxNQUFWLEVBQTFCLENBQVgsQ0FBeEIsRUFERTtBQUVGLHlEQUFvQyxNQUFwQyxFQUZFO0dBQUosQ0FHRSxPQUFPLENBQVAsRUFBVTs7QUFFVixrQ0FBYSxzQkFBYixFQUZVO0dBQVY7O0FBS0Ysc0JBQ0csS0FESCxDQUNTLE1BRFQsRUFFRyxLQUZILENBRVMsUUFGVCxFQUVtQixVQUZuQixFQUdHLFdBSEgsQ0FHZSxVQUhmLEVBbEJvQzs7QUF1QnBDLGtCQUNHLElBREgsQ0FDUSxNQURSLEVBRUcsS0FGSCxDQUVTLE1BRlQsRUFFaUIsR0FGakIsRUFHRyxLQUhILFFBR2MsTUFBTSxPQUFOLGNBQXNCLE9BQU8sU0FBUCxnQkFIcEMsRUFJRyxRQUpILG1FQUk0RSxPQUFPLFNBQVAsd0JBQW1DLE9BQU8sUUFBUCxXQUovRyxFQXZCb0M7O3FCQTZCQSx3QkFBWSxRQUFaLEVBN0JBOztNQTZCNUIsaUNBN0I0QjtNQTZCbEIsMkNBN0JrQjs7QUErQnBDLFdBQVMsT0FBVCxDQUFpQjtXQUFLLGdCQUFnQixDQUFoQixFQUFtQixhQUFuQjtHQUFMLENBQWpCLENBL0JvQzs7QUFpQ3BDLE1BQU0sTUFBTSxnQkFBTSxJQUFOLENBakN3Qjs7OEJBa0NoQixJQUFJLENBQUosS0FsQ2dCOztNQWtDNUIsb0JBbEM0Qjs7QUFvQ3BDLE1BQUksQ0FBQyxPQUFELEVBQVU7QUFDWixVQUFNLElBQUksS0FBSixDQUFVLG9FQUFWLENBQU4sQ0FEWTtHQUFkOztBQUlBLFVBQVE7QUFDTixvQkFETTtHQUFSLENBeENvQzs7QUE0Q3BDLE1BQUksVUFBVSxFQUFWLENBNUNnQzs7QUE4Q3BDLFNBQU8sSUFBUCxDQUFZLGFBQVosRUFBMkIsT0FBM0IsQ0FBbUM7V0FBSyxNQUFNLENBQU4sSUFBVyxJQUFJLENBQUosQ0FBWDtHQUFMLENBQW5DLENBOUNvQzs7QUFnRHBDLE1BQU0sb0JBQW9CLFNBQVMsSUFBVCxDQUFjO1dBQUssRUFBRSxPQUFGLEtBQWMsT0FBZDtHQUFMLENBQWxDLENBaEQ4Qjs7QUFrRHBDLE1BQUksa0JBQWtCLE9BQWxCLEVBQTJCO0FBQzdCLFdBQU8sSUFBUCxDQUFZLGtCQUFrQixPQUFsQixDQUFaLENBQXVDLE9BQXZDLENBQStDO2FBQUssUUFBUyxDQUFULElBQWUsSUFBSyxDQUFMLENBQWY7S0FBTCxDQUEvQyxDQUQ2QjtHQUEvQjs7QUFJQSxRQUFNLE9BQU4sR0FBZ0IsaUJBQWlCLEdBQWpCLENBQXFCLE9BQXJCLElBQWdDLGlCQUFpQixHQUFqQixDQUFxQixPQUFyQixFQUE4QixPQUE5QixDQUFoQyxHQUF5RSxPQUF6RSxDQXREb0I7O0FBd0RwQyxTQUFPLEtBQVAsQ0F4RG9DO0NBQXZCIiwiZmlsZSI6Im9wdGlvbnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuaW1wb3J0IGV4cGFuZEhvbWVEaXIgZnJvbSAnZXhwYW5kLWhvbWUtZGlyJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuaW1wb3J0IHlhcmdvbmF1dCBmcm9tICd5YXJnb25hdXQnXG5pbXBvcnQgeWFyZ3MgZnJvbSAneWFyZ3MnXG5cbmltcG9ydCBnZXRDb21tYW5kcyBmcm9tICdjb21tYW5kcydcbmltcG9ydCBvdXRwdXQsIHsgb3V0cHV0U3R5bGVzIH0gZnJvbSAnb3V0cHV0J1xuXG5sZXQgX29wdHNcblxuY29uc3QgeyB1c2FnZSwgY2xpQXJnIH0gPSBvdXRwdXRTdHlsZXNcblxuY29uc3QgcGF5bG9hZE1vZGlmaWVycyA9IG5ldyBNYXAoW1xuICBbICd1c2VyJywgZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICBjb25zdCB7IGFjdGlvbiwgcHVia2V5IH0gPSBwYXlsb2FkXG5cbiAgICBpZiAoYWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgcmV0dXJuIHBheWxvYWQgLy8gTm90aGluZyB0byBtb2RpZnkgd2hlbiByZW1vdmluZyBhIHVzZXJcbiAgICB9XG5cbiAgICBpZiAoIXB1YmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWMga2V5IGZpbGUgc3BlY2lmaWVkLicpXG4gICAgfVxuXG4gICAgLy8gT2theSB0byB1c2Ugc3luYyBtZXRob2QgaGVyZSwgc2luY2UgdGhpcyBpcyBhIGNvbW1hbmRsaW5lIGNsaWVudCAoaS5lLiBibG9ja2luZyB0aGUgZXZlbnQgbG9vcCBmb3IgYSBzaG9ydCB0aW1lIGRvZXMgbm90IG1hdHRlcilcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCwge3B1YmtleTogZnMucmVhZEZpbGVTeW5jKGV4cGFuZEhvbWVEaXIocHVia2V5KSwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pfSlcbiAgfSBdXG5dKVxuXG5mdW5jdGlvbiByZWdpc3Rlck9wdGlvbnMgKHsgY29tbWFuZCwgZGVzYywgdXNhZ2VTdHIsIGV4YW1wbGVzLCBvcHRpb25zIH0sIHBhcmVudE9wdGlvbnMpIHtcbiAgeWFyZ3NcbiAgICAuY29tbWFuZChjb21tYW5kLCBkZXNjLCB5YXJncyA9PiB7XG4gICAgICB5YXJnc1xuICAgICAgICAub3B0aW9ucyhPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBwYXJlbnRPcHRpb25zKSlcbiAgICAgICAgLmhlbHAoJ2hlbHAnKVxuICAgICAgICAuYWxpYXMoJ2hlbHAnLCAnaCcpXG4gICAgICAgIC51c2FnZShgXFxuJHt1c2FnZSgnVVNBR0UnKX06ICQwICR7dXNhZ2VTdHJ9YClcblxuICAgICAgaWYgKGV4YW1wbGVzKSB7XG4gICAgICAgIGV4YW1wbGVzLmZvckVhY2goKHtjbGksIGRlc2N9KSA9PiB5YXJncy5leGFtcGxlKGAkMCAke2NsaX1gLCBkZXNjKSlcbiAgICAgIH1cbiAgICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHRpb25zICgpIHtcbiAgaWYgKF9vcHRzKSB7XG4gICAgcmV0dXJuIF9vcHRzXG4gIH1cblxuICAvLyBZZXMsIHRoZSByYyBwYWNrYWdlIGNvdWxkIGJlIHVzZWQgdG8gaGFuZGxlIHRoaXMsIGJ1dCBzaW5jZSBpdCBkb2VzIG11Y2ggbW9yZSB0aGFuIHJlYWRpbmcgfi8uaGFuZG91dHJjIEkgb3B0ZWQgZm9yIGEgbXVjaCBzaW1wbGVyIGFwcHJvYWNoXG4gIGNvbnN0IHJjcGF0aCA9IGV4cGFuZEhvbWVEaXIoJ34vLmhhbmRvdXRyYycpXG5cbiAgbGV0IGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vLi4vZGVmYXVsdHMuanNvbicpXG5cbiAgdHJ5IHtcbiAgICBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhyY3BhdGgsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KSkpXG4gICAgb3V0cHV0KGBVc2luZyBkZWZhdWx0IHZhbHVlcyBmcm9tICR7cmNwYXRofWApXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBObyAuaGFuZG91dHJjIGZpbGUgZm91bmQsIG1vdmluZyBvblxuICAgIG91dHB1dChgTm8gJHtyY3BhdGh9IGZpbGUgZm91bmRgKVxuICB9XG5cbiAgeWFyZ29uYXV0XG4gICAgLnN0eWxlKCdjeWFuJylcbiAgICAuc3R5bGUoJ3llbGxvdycsICdyZXF1aXJlZCcpXG4gICAgLmVycm9yc1N0eWxlKCdyZWQuYm9sZCcpXG5cbiAgeWFyZ3NcbiAgICAuaGVscCgnaGVscCcpXG4gICAgLmFsaWFzKCdoZWxwJywgJ2gnKVxuICAgIC51c2FnZShgXFxuJHt1c2FnZSgnVVNBR0UnKX06ICQwICR7Y2xpQXJnKCdjb21tYW5kJyl9IFtvcHRpb25zXWApXG4gICAgLmVwaWxvZ3VlKGBUbyBnZXQgYSBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zIGZvciBlYWNoIGNvbW1hbmQsIHVzZSBcIiQwICR7Y2xpQXJnKCdjb21tYW5kJyl9IC1oXCIgKGUuZy4gXCIkMCAke2NsaUFyZygnZGVwbG95Jyl9IC1oXCIpYClcblxuICBjb25zdCB7IGNvbW1hbmRzLCBnbG9iYWxPcHRpb25zIH0gPSBnZXRDb21tYW5kcyhkZWZhdWx0cylcblxuICBjb21tYW5kcy5mb3JFYWNoKGMgPT4gcmVnaXN0ZXJPcHRpb25zKGMsIGdsb2JhbE9wdGlvbnMpKVxuXG4gIGNvbnN0IHJhdyA9IHlhcmdzLmFyZ3ZcbiAgY29uc3QgWyBjb21tYW5kIF0gPSByYXcuX1xuXG4gIGlmICghY29tbWFuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY29tbWFuZCBwcm92aWRlZC4gVXNlIC1oIHRvIHNlZSBhdmFpbGFibGUgY29tbWFuZHMgYW5kIG9wdGlvbnMuJylcbiAgfVxuXG4gIF9vcHRzID0ge1xuICAgIGNvbW1hbmRcbiAgfVxuXG4gIGxldCBwYXlsb2FkID0ge31cblxuICBPYmplY3Qua2V5cyhnbG9iYWxPcHRpb25zKS5mb3JFYWNoKGsgPT4gX29wdHNba10gPSByYXdba10pXG5cbiAgY29uc3QgY29tbWFuZERlZmluaXRpb24gPSBjb21tYW5kcy5maW5kKGMgPT4gYy5jb21tYW5kID09PSBjb21tYW5kKVxuXG4gIGlmIChjb21tYW5kRGVmaW5pdGlvbi5vcHRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMoY29tbWFuZERlZmluaXRpb24ub3B0aW9ucykuZm9yRWFjaChrID0+IHBheWxvYWRbIGsgXSA9IHJhd1sgayBdKVxuICB9XG5cbiAgX29wdHMucGF5bG9hZCA9IHBheWxvYWRNb2RpZmllcnMuaGFzKGNvbW1hbmQpID8gcGF5bG9hZE1vZGlmaWVycy5nZXQoY29tbWFuZCkocGF5bG9hZCkgOiBwYXlsb2FkXG5cbiAgcmV0dXJuIF9vcHRzXG59XG4iXX0=
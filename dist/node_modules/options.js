'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOptions;

var _expandHomeDir = require('expand-home-dir');

var _expandHomeDir2 = _interopRequireDefault(_expandHomeDir);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _yargonaut = require('yargonaut');

var _yargonaut2 = _interopRequireDefault(_yargonaut);

var _yargs = require('yargs');

var _yargs2 = _interopRequireDefault(_yargs);

var _commands = require('commands');

var _commands2 = _interopRequireDefault(_commands);

var _output = require('output');

var _output2 = _interopRequireDefault(_output);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _opts = undefined;

var usage = _output.outputStyles.usage;
var cliArg = _output.outputStyles.cliArg;

function registerOptions(_ref, parentOptions) {
  var command = _ref.command;
  var desc = _ref.desc;
  var usageStr = _ref.usageStr;
  var examples = _ref.examples;
  var options = _ref.options;

  _yargs2.default.command(command, desc, function (yargs) {
    yargs.options(Object.assign({}, options, parentOptions)).help('help').alias('help', 'h').usage('\n' + usage('USAGE') + ': $0 ' + usageStr);

    if (examples) {
      examples.forEach(function (_ref2) {
        var cli = _ref2.cli;
        var desc = _ref2.desc;
        return yargs.example('$0 ' + cli, desc);
      });
    }
  });
}

function getOptions() {
  if (_opts) {
    return _opts;
  }

  // Yes, the rc package could be used to handle this, but since it does much more than reading ~/.handoutrc I opted for a much simpler approach
  var rcpath = (0, _expandHomeDir2.default)('~/.handoutrc');

  var defaults = require('../../defaults.json');

  try {
    Object.assign(defaults, JSON.parse(_fs2.default.readFileSync(rcpath, { encoding: 'utf8' })));
    (0, _output2.default)('Using default values from ' + rcpath);
  } catch (e) {
    // No .handoutrc file found, moving on
    (0, _output2.default)('No ' + rcpath + ' file found');
  }

  _yargonaut2.default.style('cyan').style('yellow', 'required').errorsStyle('red.bold');

  _yargs2.default.help('help').alias('help', 'h').usage('\n' + usage('USAGE') + ': $0 ' + cliArg('command') + ' [options]').epilogue('To get a list of available options for each command, use "$0 ' + cliArg('command') + ' -h" (e.g. "$0 ' + cliArg('deploy') + ' -h")');

  var _getCommands = (0, _commands2.default)(defaults);

  var commands = _getCommands.commands;
  var globalOptions = _getCommands.globalOptions;

  commands.forEach(function (c) {
    return registerOptions(c, globalOptions);
  });

  var raw = _yargs2.default.argv;

  var _raw$_ = _slicedToArray(raw._, 1);

  var command = _raw$_[0];

  if (!command) {
    throw new Error('No command provided. Use -h to see available commands and options.');
  }

  _opts = {
    command: command,
    payload: {}
  };

  Object.keys(globalOptions).forEach(function (k) {
    return _opts[k] = raw[k];
  });

  var commandDefinition = commands.find(function (c) {
    return c.command === command;
  });

  if (commandDefinition.options) {
    Object.keys(commandDefinition.options).forEach(function (k) {
      return _opts.payload[k] = raw[k];
    });
  }

  return _opts;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlX21vZHVsZXMvb3B0aW9ucy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztrQkE2QndCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbkJ4QixJQUFJLGlCQUFKOztJQUVPLGdCQUpVLGFBSVY7SUFBTyxpQkFKRyxhQUlIOztBQUVkLFNBQVMsZUFBVCxPQUF3RSxhQUF4RSxFQUF1RjtNQUE1RCx1QkFBNEQ7TUFBbkQsaUJBQW1EO01BQTdDLHlCQUE2QztNQUFuQyx5QkFBbUM7TUFBekIsdUJBQXlCOztBQUNyRixrQkFDRyxPQURILENBQ1csT0FEWCxFQUNvQixJQURwQixFQUMwQixpQkFBUztBQUMvQixVQUNHLE9BREgsQ0FDVyxPQUFPLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLE9BQWxCLEVBQTJCLGFBQTNCLENBRFgsRUFFRyxJQUZILENBRVEsTUFGUixFQUdHLEtBSEgsQ0FHUyxNQUhULEVBR2lCLEdBSGpCLEVBSUcsS0FKSCxRQUljLE1BQU0sT0FBTixjQUFzQixRQUpwQyxFQUQrQjs7QUFPL0IsUUFBSSxRQUFKLEVBQWM7QUFDWixlQUFTLE9BQVQsQ0FBaUI7WUFBRTtZQUFLO2VBQVUsTUFBTSxPQUFOLFNBQW9CLEdBQXBCLEVBQTJCLElBQTNCO09BQWpCLENBQWpCLENBRFk7S0FBZDtHQVBzQixDQUQxQixDQURxRjtDQUF2Rjs7QUFlZSxTQUFTLFVBQVQsR0FBdUI7QUFDcEMsTUFBSSxLQUFKLEVBQVc7QUFDVCxXQUFPLEtBQVAsQ0FEUztHQUFYOzs7QUFEb0MsTUFNOUIsU0FBUyw2QkFBYyxjQUFkLENBQVQsQ0FOOEI7O0FBUXBDLE1BQUksV0FBVyxRQUFRLHFCQUFSLENBQVgsQ0FSZ0M7O0FBVXBDLE1BQUk7QUFDRixXQUFPLE1BQVAsQ0FBYyxRQUFkLEVBQXdCLEtBQUssS0FBTCxDQUFXLGFBQUcsWUFBSCxDQUFnQixNQUFoQixFQUF3QixFQUFFLFVBQVUsTUFBVixFQUExQixDQUFYLENBQXhCLEVBREU7QUFFRix5REFBb0MsTUFBcEMsRUFGRTtHQUFKLENBR0UsT0FBTyxDQUFQLEVBQVU7O0FBRVYsa0NBQWEsc0JBQWIsRUFGVTtHQUFWOztBQUtGLHNCQUNHLEtBREgsQ0FDUyxNQURULEVBRUcsS0FGSCxDQUVTLFFBRlQsRUFFbUIsVUFGbkIsRUFHRyxXQUhILENBR2UsVUFIZixFQWxCb0M7O0FBdUJwQyxrQkFDRyxJQURILENBQ1EsTUFEUixFQUVHLEtBRkgsQ0FFUyxNQUZULEVBRWlCLEdBRmpCLEVBR0csS0FISCxRQUdjLE1BQU0sT0FBTixjQUFzQixPQUFPLFNBQVAsZ0JBSHBDLEVBSUcsUUFKSCxtRUFJNEUsT0FBTyxTQUFQLHdCQUFtQyxPQUFPLFFBQVAsV0FKL0csRUF2Qm9DOztxQkE2QkYsd0JBQVksUUFBWixFQTdCRTs7TUE2QjdCLGlDQTdCNkI7TUE2Qm5CLDJDQTdCbUI7O0FBK0JwQyxXQUFTLE9BQVQsQ0FBaUI7V0FBSyxnQkFBZ0IsQ0FBaEIsRUFBbUIsYUFBbkI7R0FBTCxDQUFqQixDQS9Cb0M7O0FBaUNwQyxNQUFNLE1BQU0sZ0JBQU0sSUFBTixDQWpDd0I7OzhCQWtDaEIsSUFBSSxDQUFKLEtBbENnQjs7TUFrQzVCLG9CQWxDNEI7O0FBb0NwQyxNQUFJLENBQUMsT0FBRCxFQUFVO0FBQ1osVUFBTSxJQUFJLEtBQUosQ0FBVSxvRUFBVixDQUFOLENBRFk7R0FBZDs7QUFJQSxVQUFRO0FBQ04sb0JBRE07QUFFTixhQUFTLEVBQVQ7R0FGRixDQXhDb0M7O0FBNkNwQyxTQUFPLElBQVAsQ0FBWSxhQUFaLEVBQTJCLE9BQTNCLENBQW1DO1dBQUssTUFBTSxDQUFOLElBQVcsSUFBSSxDQUFKLENBQVg7R0FBTCxDQUFuQyxDQTdDb0M7O0FBK0NwQyxNQUFNLG9CQUFvQixTQUFTLElBQVQsQ0FBYztXQUFLLEVBQUUsT0FBRixLQUFjLE9BQWQ7R0FBTCxDQUFsQyxDQS9DOEI7O0FBaURwQyxNQUFJLGtCQUFrQixPQUFsQixFQUEyQjtBQUM3QixXQUFPLElBQVAsQ0FBWSxrQkFBa0IsT0FBbEIsQ0FBWixDQUF1QyxPQUF2QyxDQUErQzthQUFLLE1BQU0sT0FBTixDQUFlLENBQWYsSUFBcUIsSUFBSyxDQUFMLENBQXJCO0tBQUwsQ0FBL0MsQ0FENkI7R0FBL0I7O0FBSUEsU0FBTyxLQUFQLENBckRvQztDQUF2QiIsImZpbGUiOiJvcHRpb25zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBleHBhbmRIb21lRGlyIGZyb20gJ2V4cGFuZC1ob21lLWRpcidcbmltcG9ydCBmcyBmcm9tICdmcydcbmltcG9ydCB5YXJnb25hdXQgZnJvbSAneWFyZ29uYXV0J1xuaW1wb3J0IHlhcmdzIGZyb20gJ3lhcmdzJ1xuXG5pbXBvcnQgZ2V0Q29tbWFuZHMgZnJvbSAnY29tbWFuZHMnXG5pbXBvcnQgb3V0cHV0LCB7IG91dHB1dFN0eWxlcyB9IGZyb20gJ291dHB1dCdcblxubGV0IF9vcHRzXG5cbmNvbnN0IHt1c2FnZSwgY2xpQXJnfSA9IG91dHB1dFN0eWxlc1xuXG5mdW5jdGlvbiByZWdpc3Rlck9wdGlvbnMgKHtjb21tYW5kLCBkZXNjLCB1c2FnZVN0ciwgZXhhbXBsZXMsIG9wdGlvbnN9LCBwYXJlbnRPcHRpb25zKSB7XG4gIHlhcmdzXG4gICAgLmNvbW1hbmQoY29tbWFuZCwgZGVzYywgeWFyZ3MgPT4ge1xuICAgICAgeWFyZ3NcbiAgICAgICAgLm9wdGlvbnMoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgcGFyZW50T3B0aW9ucykpXG4gICAgICAgIC5oZWxwKCdoZWxwJylcbiAgICAgICAgLmFsaWFzKCdoZWxwJywgJ2gnKVxuICAgICAgICAudXNhZ2UoYFxcbiR7dXNhZ2UoJ1VTQUdFJyl9OiAkMCAke3VzYWdlU3RyfWApXG5cbiAgICAgIGlmIChleGFtcGxlcykge1xuICAgICAgICBleGFtcGxlcy5mb3JFYWNoKCh7Y2xpLCBkZXNjfSkgPT4geWFyZ3MuZXhhbXBsZShgJDAgJHtjbGl9YCwgZGVzYykpXG4gICAgICB9XG4gICAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3B0aW9ucyAoKSB7XG4gIGlmIChfb3B0cykge1xuICAgIHJldHVybiBfb3B0c1xuICB9XG5cbiAgLy8gWWVzLCB0aGUgcmMgcGFja2FnZSBjb3VsZCBiZSB1c2VkIHRvIGhhbmRsZSB0aGlzLCBidXQgc2luY2UgaXQgZG9lcyBtdWNoIG1vcmUgdGhhbiByZWFkaW5nIH4vLmhhbmRvdXRyYyBJIG9wdGVkIGZvciBhIG11Y2ggc2ltcGxlciBhcHByb2FjaFxuICBjb25zdCByY3BhdGggPSBleHBhbmRIb21lRGlyKCd+Ly5oYW5kb3V0cmMnKVxuXG4gIGxldCBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uLy4uL2RlZmF1bHRzLmpzb24nKVxuXG4gIHRyeSB7XG4gICAgT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocmNwYXRoLCB7IGVuY29kaW5nOiAndXRmOCcgfSkpKVxuICAgIG91dHB1dChgVXNpbmcgZGVmYXVsdCB2YWx1ZXMgZnJvbSAke3JjcGF0aH1gKVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTm8gLmhhbmRvdXRyYyBmaWxlIGZvdW5kLCBtb3Zpbmcgb25cbiAgICBvdXRwdXQoYE5vICR7cmNwYXRofSBmaWxlIGZvdW5kYClcbiAgfVxuXG4gIHlhcmdvbmF1dFxuICAgIC5zdHlsZSgnY3lhbicpXG4gICAgLnN0eWxlKCd5ZWxsb3cnLCAncmVxdWlyZWQnKVxuICAgIC5lcnJvcnNTdHlsZSgncmVkLmJvbGQnKVxuXG4gIHlhcmdzXG4gICAgLmhlbHAoJ2hlbHAnKVxuICAgIC5hbGlhcygnaGVscCcsICdoJylcbiAgICAudXNhZ2UoYFxcbiR7dXNhZ2UoJ1VTQUdFJyl9OiAkMCAke2NsaUFyZygnY29tbWFuZCcpfSBbb3B0aW9uc11gKVxuICAgIC5lcGlsb2d1ZShgVG8gZ2V0IGEgbGlzdCBvZiBhdmFpbGFibGUgb3B0aW9ucyBmb3IgZWFjaCBjb21tYW5kLCB1c2UgXCIkMCAke2NsaUFyZygnY29tbWFuZCcpfSAtaFwiIChlLmcuIFwiJDAgJHtjbGlBcmcoJ2RlcGxveScpfSAtaFwiKWApXG5cbiAgY29uc3Qge2NvbW1hbmRzLCBnbG9iYWxPcHRpb25zfSA9IGdldENvbW1hbmRzKGRlZmF1bHRzKVxuXG4gIGNvbW1hbmRzLmZvckVhY2goYyA9PiByZWdpc3Rlck9wdGlvbnMoYywgZ2xvYmFsT3B0aW9ucykpXG5cbiAgY29uc3QgcmF3ID0geWFyZ3MuYXJndlxuICBjb25zdCBbIGNvbW1hbmQgXSA9IHJhdy5fXG5cbiAgaWYgKCFjb21tYW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb21tYW5kIHByb3ZpZGVkLiBVc2UgLWggdG8gc2VlIGF2YWlsYWJsZSBjb21tYW5kcyBhbmQgb3B0aW9ucy4nKVxuICB9XG5cbiAgX29wdHMgPSB7XG4gICAgY29tbWFuZCxcbiAgICBwYXlsb2FkOiB7fVxuICB9XG5cbiAgT2JqZWN0LmtleXMoZ2xvYmFsT3B0aW9ucykuZm9yRWFjaChrID0+IF9vcHRzW2tdID0gcmF3W2tdKVxuXG4gIGNvbnN0IGNvbW1hbmREZWZpbml0aW9uID0gY29tbWFuZHMuZmluZChjID0+IGMuY29tbWFuZCA9PT0gY29tbWFuZClcblxuICBpZiAoY29tbWFuZERlZmluaXRpb24ub3B0aW9ucykge1xuICAgIE9iamVjdC5rZXlzKGNvbW1hbmREZWZpbml0aW9uLm9wdGlvbnMpLmZvckVhY2goayA9PiBfb3B0cy5wYXlsb2FkWyBrIF0gPSByYXdbIGsgXSlcbiAgfVxuXG4gIHJldHVybiBfb3B0c1xufVxuIl19
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getOptions;

var _expandHomeDir = require('expand-home-dir');

var _expandHomeDir2 = _interopRequireDefault(_expandHomeDir);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _yargonaut = require('yargonaut');

var _yargonaut2 = _interopRequireDefault(_yargonaut);

var _yargs = require('yargs');

var _yargs2 = _interopRequireDefault(_yargs);

var _output = require('output');

var _output2 = _interopRequireDefault(_output);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _opts = undefined;

// I might as well just have exported the options object itself, but it bugged me that the calls to output() might then
// produce output (or fail, in case of invalid arguments) ahead of the first outputTitle() call.
function getOptions() {
    if (_opts) {
        return _opts;
    }

    // Yes, the rc package could be used to handle this, but since it does much more than reading ~/.handoutrc I opted for a much simpler approach
    var rcpath = (0, _expandHomeDir2.default)('~/.handoutrc');

    var defaults = require('../../defaults.json');

    try {
        Object.assign(defaults, JSON.parse(_fs2.default.readFileSync(rcpath, { encoding: 'utf8' })));
        (0, _output2.default)('Using default values from ' + rcpath);
    } catch (e) {
        console.log(e.message);
        // No .handoutrc file found, moving on
        (0, _output2.default)('No ' + rcpath + ' file found');
    }

    var args = {
        'app': {
            alias: 'a',
            demand: true,
            describe: 'App identifier (e.g. deepsea, passerby, ...)'
        },
        'targets': {
            alias: 't',
            demand: true,
            array: true,
            describe: 'Space separated list of targets to deploy to(e.g. "--targets callisto titan"). Use "all" if you want to deploy to all available hosts'
        },
        'check': {
            alias: 'c',
            type: 'boolean',
            default: defaults.check,
            describe: 'Perform check, don\'t change anything'
        },
        'username': {
            alias: 'u',
            default: defaults.username || process.env.USER,
            describe: 'Username to use when connecting to deployment server'
        },
        'keyfile': {
            alias: 'k',
            default: defaults.keyfile,
            describe: 'Path to private key'
        },
        'server': {
            alias: 's',
            default: defaults.server,
            describe: 'Full server URL'
        }
    };

    _yargonaut2.default.style('cyan').style('yellow', 'required').errorsStyle('red.bold');

    var usage = _output.outputStyles.usage;
    var cliArg = _output.outputStyles.cliArg;

    _yargs2.default.options(args).usage('\n' + usage('USAGE') + ': $0 -a ' + cliArg('appIdentifier') + ' -t ' + cliArg('target') + '[ ' + cliArg('target') + ' ...]').alias('help', 'h').help('help').example('$0 -a deepsea -t callisto', 'Deploy app "deepsea" to target "callisto"').example('$0 -a passerby -t all -u some_user -k ~/.ssh/id_rsa.someuser --check', 'Perform a mock-deployment of "passerby" to all available targets, connecting as user "some_user", using private key file "~/.ssh/id_rsa.someuser".');

    var raw = _yargs2.default.argv;

    _opts = {};

    // Only export full names
    Object.keys(args).forEach(function (k) {
        return _opts[k] = raw[k];
    });

    return _opts;
}
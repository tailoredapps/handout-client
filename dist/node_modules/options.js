'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOptions;

var _expandHomeDir = require('expand-home-dir');

var _expandHomeDir2 = _interopRequireDefault(_expandHomeDir);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _yargonaut = require('yargonaut');

var _yargonaut2 = _interopRequireDefault(_yargonaut);

var _yargs = require('yargs');

var _yargs2 = _interopRequireDefault(_yargs);

var _commands = require('commands');

var _commands2 = _interopRequireDefault(_commands);

var _output = require('output');

var _output2 = _interopRequireDefault(_output);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _opts = undefined;

var usage = _output.outputStyles.usage;
var cliArg = _output.outputStyles.cliArg;

var payloadModifiers = new Map([['user', function (payload) {
  var action = payload.action;
  var pubkey = payload.pubkey;

  if (action === 'remove') {
    return payload; // Nothing to modify when removing a user
  }

  if (!pubkey) {
    throw new Error('No public key file specified.');
  }

  // Okay to use sync method here, since this is a commandline client (i.e. blocking the event loop for a short time does not matter)
  return Object.assign({}, payload, { pubkey: _fs2.default.readFileSync((0, _expandHomeDir2.default)(pubkey), { encoding: 'utf8' }) });
}]]);

function registerOptions(_ref, parentOptions) {
  var command = _ref.command;
  var desc = _ref.desc;
  var usageStr = _ref.usageStr;
  var examples = _ref.examples;
  var options = _ref.options;

  _yargs2.default.command(command, desc, function (yargs) {
    yargs.options(Object.assign({}, options, parentOptions)).help('help').alias('help', 'h').usage('\n' + usage('USAGE') + ': $0 ' + usageStr);

    if (examples) {
      examples.forEach(function (_ref2) {
        var cli = _ref2.cli;
        var desc = _ref2.desc;
        return yargs.example('$0 ' + cli, desc);
      });
    }
  });
}

function getOptions() {
  if (_opts) {
    return _opts;
  }

  // Yes, the rc package could be used to handle this, but since it does much more than reading ~/.handoutrc I opted for a much simpler approach
  var rcpath = (0, _expandHomeDir2.default)('~/.handoutrc');

  var defaults = require('../../defaults.json');

  try {
    Object.assign(defaults, JSON.parse(_fs2.default.readFileSync(rcpath, { encoding: 'utf8' })));
    (0, _output2.default)('Using default values from ' + rcpath);
  } catch (e) {
    // No .handoutrc file found, moving on
    (0, _output2.default)('No ' + rcpath + ' file found');
  }

  _yargonaut2.default.style('cyan').style('yellow', 'required').errorsStyle('red.bold');

  _yargs2.default.help('help').alias('help', 'h').usage('\n' + usage('USAGE') + ': $0 ' + cliArg('command') + ' [options]').epilogue('To get a list of available options for each command, use "$0 ' + cliArg('command') + ' -h" (e.g. "$0 ' + cliArg('deploy') + ' -h")');

  var _getCommands = (0, _commands2.default)(defaults);

  var commands = _getCommands.commands;
  var globalOptions = _getCommands.globalOptions;

  commands.forEach(function (c) {
    return registerOptions(c, globalOptions);
  });

  var raw = _yargs2.default.argv;

  var _raw$_ = _slicedToArray(raw._, 1);

  var command = _raw$_[0];

  if (!command) {
    throw new Error('No command provided. Use -h to see available commands and options.');
  }

  _opts = {
    command: command
  };

  var payload = {};

  Object.keys(globalOptions).forEach(function (k) {
    return _opts[k] = raw[k];
  });

  var commandDefinition = commands.find(function (c) {
    return c.command === command;
  });

  if (commandDefinition.options) {
    Object.keys(commandDefinition.options).forEach(function (k) {
      return payload[k] = raw[k];
    });
  }

  _opts.payload = payloadModifiers.has(command) ? payloadModifiers.get(command)(payload) : payload;

  return _opts;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlX21vZHVsZXMvb3B0aW9ucy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztrQkE2Q3dCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbkN4QixJQUFJLGlCQUFKOztJQUVPLGdCQUpVLGFBSVY7SUFBTyxpQkFKRyxhQUlIOztBQUNkLElBQU0sbUJBQW1CLElBQUksR0FBSixDQUFRLENBQy9CLENBQUUsTUFBRixFQUFVLFVBQVUsT0FBVixFQUFtQjtNQUNuQixTQUFtQixRQUFuQixPQURtQjtNQUNYLFNBQVcsUUFBWCxPQURXOztBQUczQixNQUFJLFdBQVcsUUFBWCxFQUFxQjtBQUN2QixXQUFPLE9BQVA7QUFEdUIsR0FBekI7O0FBSUEsTUFBSSxDQUFDLE1BQUQsRUFBUztBQUNYLFVBQU0sSUFBSSxLQUFKLENBQVUsK0JBQVYsQ0FBTixDQURXO0dBQWI7OztBQVAyQixTQVlwQixPQUFPLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLE9BQWxCLEVBQTJCLEVBQUMsUUFBUSxhQUFHLFlBQUgsQ0FBZ0IsNkJBQWMsTUFBZCxDQUFoQixFQUF1QyxFQUFFLFVBQVUsTUFBVixFQUF6QyxDQUFSLEVBQTVCLENBQVAsQ0FaMkI7Q0FBbkIsQ0FEcUIsQ0FBUixDQUFuQjs7QUFpQk4sU0FBUyxlQUFULE9BQXdFLGFBQXhFLEVBQXVGO01BQTVELHVCQUE0RDtNQUFuRCxpQkFBbUQ7TUFBN0MseUJBQTZDO01BQW5DLHlCQUFtQztNQUF6Qix1QkFBeUI7O0FBQ3JGLGtCQUNHLE9BREgsQ0FDVyxPQURYLEVBQ29CLElBRHBCLEVBQzBCLGlCQUFTO0FBQy9CLFVBQ0csT0FESCxDQUNXLE9BQU8sTUFBUCxDQUFjLEVBQWQsRUFBa0IsT0FBbEIsRUFBMkIsYUFBM0IsQ0FEWCxFQUVHLElBRkgsQ0FFUSxNQUZSLEVBR0csS0FISCxDQUdTLE1BSFQsRUFHaUIsR0FIakIsRUFJRyxLQUpILFFBSWMsTUFBTSxPQUFOLGNBQXNCLFFBSnBDLEVBRCtCOztBQU8vQixRQUFJLFFBQUosRUFBYztBQUNaLGVBQVMsT0FBVCxDQUFpQjtZQUFFO1lBQUs7ZUFBVSxNQUFNLE9BQU4sU0FBb0IsR0FBcEIsRUFBMkIsSUFBM0I7T0FBakIsQ0FBakIsQ0FEWTtLQUFkO0dBUHNCLENBRDFCLENBRHFGO0NBQXZGOztBQWVlLFNBQVMsVUFBVCxHQUF1QjtBQUNwQyxNQUFJLEtBQUosRUFBVztBQUNULFdBQU8sS0FBUCxDQURTO0dBQVg7OztBQURvQyxNQU05QixTQUFTLDZCQUFjLGNBQWQsQ0FBVCxDQU44Qjs7QUFRcEMsTUFBSSxXQUFXLFFBQVEscUJBQVIsQ0FBWCxDQVJnQzs7QUFVcEMsTUFBSTtBQUNGLFdBQU8sTUFBUCxDQUFjLFFBQWQsRUFBd0IsS0FBSyxLQUFMLENBQVcsYUFBRyxZQUFILENBQWdCLE1BQWhCLEVBQXdCLEVBQUUsVUFBVSxNQUFWLEVBQTFCLENBQVgsQ0FBeEIsRUFERTtBQUVGLHlEQUFvQyxNQUFwQyxFQUZFO0dBQUosQ0FHRSxPQUFPLENBQVAsRUFBVTs7QUFFVixrQ0FBYSxzQkFBYixFQUZVO0dBQVY7O0FBS0Ysc0JBQ0csS0FESCxDQUNTLE1BRFQsRUFFRyxLQUZILENBRVMsUUFGVCxFQUVtQixVQUZuQixFQUdHLFdBSEgsQ0FHZSxVQUhmLEVBbEJvQzs7QUF1QnBDLGtCQUNHLElBREgsQ0FDUSxNQURSLEVBRUcsS0FGSCxDQUVTLE1BRlQsRUFFaUIsR0FGakIsRUFHRyxLQUhILFFBR2MsTUFBTSxPQUFOLGNBQXNCLE9BQU8sU0FBUCxnQkFIcEMsRUFJRyxRQUpILG1FQUk0RSxPQUFPLFNBQVAsd0JBQW1DLE9BQU8sUUFBUCxXQUovRyxFQXZCb0M7O3FCQTZCRix3QkFBWSxRQUFaLEVBN0JFOztNQTZCN0IsaUNBN0I2QjtNQTZCbkIsMkNBN0JtQjs7QUErQnBDLFdBQVMsT0FBVCxDQUFpQjtXQUFLLGdCQUFnQixDQUFoQixFQUFtQixhQUFuQjtHQUFMLENBQWpCLENBL0JvQzs7QUFpQ3BDLE1BQU0sTUFBTSxnQkFBTSxJQUFOLENBakN3Qjs7OEJBa0NoQixJQUFJLENBQUosS0FsQ2dCOztNQWtDNUIsb0JBbEM0Qjs7QUFvQ3BDLE1BQUksQ0FBQyxPQUFELEVBQVU7QUFDWixVQUFNLElBQUksS0FBSixDQUFVLG9FQUFWLENBQU4sQ0FEWTtHQUFkOztBQUlBLFVBQVE7QUFDTixvQkFETTtHQUFSLENBeENvQzs7QUE0Q3BDLE1BQUksVUFBVSxFQUFWLENBNUNnQzs7QUE4Q3BDLFNBQU8sSUFBUCxDQUFZLGFBQVosRUFBMkIsT0FBM0IsQ0FBbUM7V0FBSyxNQUFNLENBQU4sSUFBVyxJQUFJLENBQUosQ0FBWDtHQUFMLENBQW5DLENBOUNvQzs7QUFnRHBDLE1BQU0sb0JBQW9CLFNBQVMsSUFBVCxDQUFjO1dBQUssRUFBRSxPQUFGLEtBQWMsT0FBZDtHQUFMLENBQWxDLENBaEQ4Qjs7QUFrRHBDLE1BQUksa0JBQWtCLE9BQWxCLEVBQTJCO0FBQzdCLFdBQU8sSUFBUCxDQUFZLGtCQUFrQixPQUFsQixDQUFaLENBQXVDLE9BQXZDLENBQStDO2FBQUssUUFBUyxDQUFULElBQWUsSUFBSyxDQUFMLENBQWY7S0FBTCxDQUEvQyxDQUQ2QjtHQUEvQjs7QUFJQSxRQUFNLE9BQU4sR0FBZ0IsaUJBQWlCLEdBQWpCLENBQXFCLE9BQXJCLElBQWdDLGlCQUFpQixHQUFqQixDQUFxQixPQUFyQixFQUE4QixPQUE5QixDQUFoQyxHQUF5RSxPQUF6RSxDQXREb0I7O0FBd0RwQyxTQUFPLEtBQVAsQ0F4RG9DO0NBQXZCIiwiZmlsZSI6Im9wdGlvbnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuaW1wb3J0IGV4cGFuZEhvbWVEaXIgZnJvbSAnZXhwYW5kLWhvbWUtZGlyJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuaW1wb3J0IHlhcmdvbmF1dCBmcm9tICd5YXJnb25hdXQnXG5pbXBvcnQgeWFyZ3MgZnJvbSAneWFyZ3MnXG5cbmltcG9ydCBnZXRDb21tYW5kcyBmcm9tICdjb21tYW5kcydcbmltcG9ydCBvdXRwdXQsIHsgb3V0cHV0U3R5bGVzIH0gZnJvbSAnb3V0cHV0J1xuXG5sZXQgX29wdHNcblxuY29uc3Qge3VzYWdlLCBjbGlBcmd9ID0gb3V0cHV0U3R5bGVzXG5jb25zdCBwYXlsb2FkTW9kaWZpZXJzID0gbmV3IE1hcChbXG4gIFsgJ3VzZXInLCBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIGNvbnN0IHsgYWN0aW9uLCBwdWJrZXkgfSA9IHBheWxvYWRcblxuICAgIGlmIChhY3Rpb24gPT09ICdyZW1vdmUnKSB7XG4gICAgICByZXR1cm4gcGF5bG9hZCAvLyBOb3RoaW5nIHRvIG1vZGlmeSB3aGVuIHJlbW92aW5nIGEgdXNlclxuICAgIH1cblxuICAgIGlmICghcHVia2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHB1YmxpYyBrZXkgZmlsZSBzcGVjaWZpZWQuJylcbiAgICB9XG5cbiAgICAvLyBPa2F5IHRvIHVzZSBzeW5jIG1ldGhvZCBoZXJlLCBzaW5jZSB0aGlzIGlzIGEgY29tbWFuZGxpbmUgY2xpZW50IChpLmUuIGJsb2NraW5nIHRoZSBldmVudCBsb29wIGZvciBhIHNob3J0IHRpbWUgZG9lcyBub3QgbWF0dGVyKVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwYXlsb2FkLCB7cHVia2V5OiBmcy5yZWFkRmlsZVN5bmMoZXhwYW5kSG9tZURpcihwdWJrZXkpLCB7IGVuY29kaW5nOiAndXRmOCcgfSl9KVxuICB9IF1cbl0pXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyT3B0aW9ucyAoe2NvbW1hbmQsIGRlc2MsIHVzYWdlU3RyLCBleGFtcGxlcywgb3B0aW9uc30sIHBhcmVudE9wdGlvbnMpIHtcbiAgeWFyZ3NcbiAgICAuY29tbWFuZChjb21tYW5kLCBkZXNjLCB5YXJncyA9PiB7XG4gICAgICB5YXJnc1xuICAgICAgICAub3B0aW9ucyhPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBwYXJlbnRPcHRpb25zKSlcbiAgICAgICAgLmhlbHAoJ2hlbHAnKVxuICAgICAgICAuYWxpYXMoJ2hlbHAnLCAnaCcpXG4gICAgICAgIC51c2FnZShgXFxuJHt1c2FnZSgnVVNBR0UnKX06ICQwICR7dXNhZ2VTdHJ9YClcblxuICAgICAgaWYgKGV4YW1wbGVzKSB7XG4gICAgICAgIGV4YW1wbGVzLmZvckVhY2goKHtjbGksIGRlc2N9KSA9PiB5YXJncy5leGFtcGxlKGAkMCAke2NsaX1gLCBkZXNjKSlcbiAgICAgIH1cbiAgICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHRpb25zICgpIHtcbiAgaWYgKF9vcHRzKSB7XG4gICAgcmV0dXJuIF9vcHRzXG4gIH1cblxuICAvLyBZZXMsIHRoZSByYyBwYWNrYWdlIGNvdWxkIGJlIHVzZWQgdG8gaGFuZGxlIHRoaXMsIGJ1dCBzaW5jZSBpdCBkb2VzIG11Y2ggbW9yZSB0aGFuIHJlYWRpbmcgfi8uaGFuZG91dHJjIEkgb3B0ZWQgZm9yIGEgbXVjaCBzaW1wbGVyIGFwcHJvYWNoXG4gIGNvbnN0IHJjcGF0aCA9IGV4cGFuZEhvbWVEaXIoJ34vLmhhbmRvdXRyYycpXG5cbiAgbGV0IGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vLi4vZGVmYXVsdHMuanNvbicpXG5cbiAgdHJ5IHtcbiAgICBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhyY3BhdGgsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KSkpXG4gICAgb3V0cHV0KGBVc2luZyBkZWZhdWx0IHZhbHVlcyBmcm9tICR7cmNwYXRofWApXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBObyAuaGFuZG91dHJjIGZpbGUgZm91bmQsIG1vdmluZyBvblxuICAgIG91dHB1dChgTm8gJHtyY3BhdGh9IGZpbGUgZm91bmRgKVxuICB9XG5cbiAgeWFyZ29uYXV0XG4gICAgLnN0eWxlKCdjeWFuJylcbiAgICAuc3R5bGUoJ3llbGxvdycsICdyZXF1aXJlZCcpXG4gICAgLmVycm9yc1N0eWxlKCdyZWQuYm9sZCcpXG5cbiAgeWFyZ3NcbiAgICAuaGVscCgnaGVscCcpXG4gICAgLmFsaWFzKCdoZWxwJywgJ2gnKVxuICAgIC51c2FnZShgXFxuJHt1c2FnZSgnVVNBR0UnKX06ICQwICR7Y2xpQXJnKCdjb21tYW5kJyl9IFtvcHRpb25zXWApXG4gICAgLmVwaWxvZ3VlKGBUbyBnZXQgYSBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zIGZvciBlYWNoIGNvbW1hbmQsIHVzZSBcIiQwICR7Y2xpQXJnKCdjb21tYW5kJyl9IC1oXCIgKGUuZy4gXCIkMCAke2NsaUFyZygnZGVwbG95Jyl9IC1oXCIpYClcblxuICBjb25zdCB7Y29tbWFuZHMsIGdsb2JhbE9wdGlvbnN9ID0gZ2V0Q29tbWFuZHMoZGVmYXVsdHMpXG5cbiAgY29tbWFuZHMuZm9yRWFjaChjID0+IHJlZ2lzdGVyT3B0aW9ucyhjLCBnbG9iYWxPcHRpb25zKSlcblxuICBjb25zdCByYXcgPSB5YXJncy5hcmd2XG4gIGNvbnN0IFsgY29tbWFuZCBdID0gcmF3Ll9cblxuICBpZiAoIWNvbW1hbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbW1hbmQgcHJvdmlkZWQuIFVzZSAtaCB0byBzZWUgYXZhaWxhYmxlIGNvbW1hbmRzIGFuZCBvcHRpb25zLicpXG4gIH1cblxuICBfb3B0cyA9IHtcbiAgICBjb21tYW5kXG4gIH1cblxuICBsZXQgcGF5bG9hZCA9IHt9XG5cbiAgT2JqZWN0LmtleXMoZ2xvYmFsT3B0aW9ucykuZm9yRWFjaChrID0+IF9vcHRzW2tdID0gcmF3W2tdKVxuXG4gIGNvbnN0IGNvbW1hbmREZWZpbml0aW9uID0gY29tbWFuZHMuZmluZChjID0+IGMuY29tbWFuZCA9PT0gY29tbWFuZClcblxuICBpZiAoY29tbWFuZERlZmluaXRpb24ub3B0aW9ucykge1xuICAgIE9iamVjdC5rZXlzKGNvbW1hbmREZWZpbml0aW9uLm9wdGlvbnMpLmZvckVhY2goayA9PiBwYXlsb2FkWyBrIF0gPSByYXdbIGsgXSlcbiAgfVxuXG4gIF9vcHRzLnBheWxvYWQgPSBwYXlsb2FkTW9kaWZpZXJzLmhhcyhjb21tYW5kKSA/IHBheWxvYWRNb2RpZmllcnMuZ2V0KGNvbW1hbmQpKHBheWxvYWQpIDogcGF5bG9hZFxuXG4gIHJldHVybiBfb3B0c1xufVxuIl19
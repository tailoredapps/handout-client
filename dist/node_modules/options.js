'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOptions;

var _expandHomeDir = require('expand-home-dir');

var _expandHomeDir2 = _interopRequireDefault(_expandHomeDir);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _yargonaut = require('yargonaut');

var _yargonaut2 = _interopRequireDefault(_yargonaut);

var _yargs = require('yargs');

var _yargs2 = _interopRequireDefault(_yargs);

var _output = require('output');

var _output2 = _interopRequireDefault(_output);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _opts = undefined;

// I might as well just have exported the options object itself, but it bugged me that the calls to output() might then
// produce output (or fail, in case of invalid arguments) ahead of the first outputTitle() call.
function getOptions() {
  if (_opts) {
    return _opts;
  }

  // Yes, the rc package could be used to handle this, but since it does much more than reading ~/.handoutrc I opted for a much simpler approach
  var rcpath = (0, _expandHomeDir2.default)('~/.handoutrc');

  var defaults = require('../../defaults.json');

  try {
    Object.assign(defaults, JSON.parse(_fs2.default.readFileSync(rcpath, { encoding: 'utf8' })));
    (0, _output2.default)('Using default values from ' + rcpath);
  } catch (e) {
    // No .handoutrc file found, moving on
    (0, _output2.default)('No ' + rcpath + ' file found');
  }

  var args = {
    'app': {
      alias: 'a',
      demand: true,
      describe: 'App identifier (e.g. deepsea, passerby, ...)'
    },
    'targets': {
      alias: 't',
      demand: true,
      array: true,
      describe: 'Space separated list of targets to deploy to(e.g. "--targets callisto titan"). Use "all" if you want to deploy to all available hosts'
    },
    'check': {
      alias: 'c',
      type: 'boolean',
      default: defaults.check,
      describe: "Perform check, don't change anything"
    },
    'username': {
      alias: 'u',
      default: defaults.username || process.env.USER,
      describe: 'Username to use when connecting to deployment server'
    },
    'keyfile': {
      alias: 'k',
      default: defaults.keyfile,
      describe: 'Path to private key'
    },
    'server': {
      alias: 's',
      default: defaults.server,
      describe: 'Full server URL'
    }
  };

  _yargonaut2.default.style('cyan').style('yellow', 'required').errorsStyle('red.bold');

  var usage = _output.outputStyles.usage;
  var cliArg = _output.outputStyles.cliArg;

  _yargs2.default.options(args).usage('\n' + usage('USAGE') + ': $0 -a ' + cliArg('appIdentifier') + ' -t ' + cliArg('target') + '[ ' + cliArg('target') + ' ...]').alias('help', 'h').help('help').example('$0 -a deepsea -t callisto', 'Deploy app "deepsea" to target "callisto"').example('$0 -a passerby -t all -u some_user -k ~/.ssh/id_rsa.someuser --check', 'Perform a mock-deployment of "passerby" to all available targets, connecting as user "some_user", using private key file "~/.ssh/id_rsa.someuser".');

  var raw = _yargs2.default.argv;

  _opts = {};

  // Only export full names
  Object.keys(args).forEach(function (k) {
    return _opts[k] = raw[k];
  });

  return _opts;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlX21vZHVsZXMvb3B0aW9ucy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7a0JBYXdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFKeEIsSUFBSSxpQkFBSjs7OztBQUllLFNBQVMsVUFBVCxHQUF1QjtBQUNwQyxNQUFJLEtBQUosRUFBVztBQUNULFdBQU8sS0FBUCxDQURTO0dBQVg7OztBQURvQyxNQU05QixTQUFTLDZCQUFjLGNBQWQsQ0FBVCxDQU44Qjs7QUFRcEMsTUFBSSxXQUFXLFFBQVEscUJBQVIsQ0FBWCxDQVJnQzs7QUFVcEMsTUFBSTtBQUNGLFdBQU8sTUFBUCxDQUFjLFFBQWQsRUFBd0IsS0FBSyxLQUFMLENBQVcsYUFBRyxZQUFILENBQWdCLE1BQWhCLEVBQXdCLEVBQUUsVUFBVSxNQUFWLEVBQTFCLENBQVgsQ0FBeEIsRUFERTtBQUVGLHlEQUFvQyxNQUFwQyxFQUZFO0dBQUosQ0FHRSxPQUFPLENBQVAsRUFBVTs7QUFFVixrQ0FBYSxzQkFBYixFQUZVO0dBQVY7O0FBS0YsTUFBTSxPQUFPO0FBQ1gsV0FBTztBQUNMLGFBQU8sR0FBUDtBQUNBLGNBQVEsSUFBUjtBQUNBLGdCQUFVLDhDQUFWO0tBSEY7QUFLQSxlQUFXO0FBQ1QsYUFBTyxHQUFQO0FBQ0EsY0FBUSxJQUFSO0FBQ0EsYUFBTyxJQUFQO0FBQ0EsZ0JBQVUsdUlBQVY7S0FKRjtBQU1BLGFBQVM7QUFDUCxhQUFPLEdBQVA7QUFDQSxZQUFNLFNBQU47QUFDQSxlQUFTLFNBQVMsS0FBVDtBQUNULGdCQUFVLHNDQUFWO0tBSkY7QUFNQSxnQkFBWTtBQUNWLGFBQU8sR0FBUDtBQUNBLGVBQVMsU0FBUyxRQUFULElBQXFCLFFBQVEsR0FBUixDQUFZLElBQVo7QUFDOUIsZ0JBQVUsc0RBQVY7S0FIRjtBQUtBLGVBQVc7QUFDVCxhQUFPLEdBQVA7QUFDQSxlQUFTLFNBQVMsT0FBVDtBQUNULGdCQUFVLHFCQUFWO0tBSEY7QUFLQSxjQUFVO0FBQ1IsYUFBTyxHQUFQO0FBQ0EsZUFBUyxTQUFTLE1BQVQ7QUFDVCxnQkFBVSxpQkFBVjtLQUhGO0dBNUJJLENBbEI4Qjs7QUFxRHBDLHNCQUNHLEtBREgsQ0FDUyxNQURULEVBRUcsS0FGSCxDQUVTLFFBRlQsRUFFbUIsVUFGbkIsRUFHRyxXQUhILENBR2UsVUFIZixFQXJEb0M7O01BMEQ3QixnQkFoRVEsYUFnRVIsTUExRDZCO01BMER0QixpQkFoRUMsYUFnRUQsT0ExRHNCOztBQTREcEMsa0JBQ0csT0FESCxDQUNXLElBRFgsRUFFRyxLQUZILFFBRWMsTUFBTSxPQUFOLGlCQUF5QixPQUFPLGVBQVAsYUFBOEIsT0FBTyxRQUFQLFdBQXFCLE9BQU8sUUFBUCxXQUYxRixFQUdHLEtBSEgsQ0FHUyxNQUhULEVBR2lCLEdBSGpCLEVBSUcsSUFKSCxDQUlRLE1BSlIsRUFLRyxPQUxILENBS1csMkJBTFgsRUFLd0MsMkNBTHhDLEVBTUcsT0FOSCxDQU1XLHNFQU5YLEVBTW1GLG9KQU5uRixFQTVEb0M7O0FBb0VwQyxNQUFNLE1BQU0sZ0JBQU0sSUFBTixDQXBFd0I7O0FBc0VwQyxVQUFRLEVBQVI7OztBQXRFb0MsUUF5RXBDLENBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsT0FBbEIsQ0FBMEI7V0FBSyxNQUFPLENBQVAsSUFBYSxJQUFLLENBQUwsQ0FBYjtHQUFMLENBQTFCLENBekVvQzs7QUEyRXBDLFNBQU8sS0FBUCxDQTNFb0M7Q0FBdkIiLCJmaWxlIjoib3B0aW9ucy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgZXhwYW5kSG9tZURpciBmcm9tICdleHBhbmQtaG9tZS1kaXInXG5pbXBvcnQgZnMgZnJvbSAnZnMnXG5pbXBvcnQgeWFyZ29uYXV0IGZyb20gJ3lhcmdvbmF1dCdcbmltcG9ydCB5YXJncyBmcm9tICd5YXJncydcblxuaW1wb3J0IG91dHB1dCwgeyBvdXRwdXRTdHlsZXMgfSBmcm9tICdvdXRwdXQnXG5cbmxldCBfb3B0c1xuXG4vLyBJIG1pZ2h0IGFzIHdlbGwganVzdCBoYXZlIGV4cG9ydGVkIHRoZSBvcHRpb25zIG9iamVjdCBpdHNlbGYsIGJ1dCBpdCBidWdnZWQgbWUgdGhhdCB0aGUgY2FsbHMgdG8gb3V0cHV0KCkgbWlnaHQgdGhlblxuLy8gcHJvZHVjZSBvdXRwdXQgKG9yIGZhaWwsIGluIGNhc2Ugb2YgaW52YWxpZCBhcmd1bWVudHMpIGFoZWFkIG9mIHRoZSBmaXJzdCBvdXRwdXRUaXRsZSgpIGNhbGwuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHRpb25zICgpIHtcbiAgaWYgKF9vcHRzKSB7XG4gICAgcmV0dXJuIF9vcHRzXG4gIH1cblxuICAvLyBZZXMsIHRoZSByYyBwYWNrYWdlIGNvdWxkIGJlIHVzZWQgdG8gaGFuZGxlIHRoaXMsIGJ1dCBzaW5jZSBpdCBkb2VzIG11Y2ggbW9yZSB0aGFuIHJlYWRpbmcgfi8uaGFuZG91dHJjIEkgb3B0ZWQgZm9yIGEgbXVjaCBzaW1wbGVyIGFwcHJvYWNoXG4gIGNvbnN0IHJjcGF0aCA9IGV4cGFuZEhvbWVEaXIoJ34vLmhhbmRvdXRyYycpXG5cbiAgbGV0IGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vLi4vZGVmYXVsdHMuanNvbicpXG5cbiAgdHJ5IHtcbiAgICBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhyY3BhdGgsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KSkpXG4gICAgb3V0cHV0KGBVc2luZyBkZWZhdWx0IHZhbHVlcyBmcm9tICR7cmNwYXRofWApXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBObyAuaGFuZG91dHJjIGZpbGUgZm91bmQsIG1vdmluZyBvblxuICAgIG91dHB1dChgTm8gJHtyY3BhdGh9IGZpbGUgZm91bmRgKVxuICB9XG5cbiAgY29uc3QgYXJncyA9IHtcbiAgICAnYXBwJzoge1xuICAgICAgYWxpYXM6ICdhJyxcbiAgICAgIGRlbWFuZDogdHJ1ZSxcbiAgICAgIGRlc2NyaWJlOiAnQXBwIGlkZW50aWZpZXIgKGUuZy4gZGVlcHNlYSwgcGFzc2VyYnksIC4uLiknXG4gICAgfSxcbiAgICAndGFyZ2V0cyc6IHtcbiAgICAgIGFsaWFzOiAndCcsXG4gICAgICBkZW1hbmQ6IHRydWUsXG4gICAgICBhcnJheTogdHJ1ZSxcbiAgICAgIGRlc2NyaWJlOiAnU3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgdGFyZ2V0cyB0byBkZXBsb3kgdG8oZS5nLiBcIi0tdGFyZ2V0cyBjYWxsaXN0byB0aXRhblwiKS4gVXNlIFwiYWxsXCIgaWYgeW91IHdhbnQgdG8gZGVwbG95IHRvIGFsbCBhdmFpbGFibGUgaG9zdHMnXG4gICAgfSxcbiAgICAnY2hlY2snOiB7XG4gICAgICBhbGlhczogJ2MnLFxuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZGVmYXVsdHMuY2hlY2ssXG4gICAgICBkZXNjcmliZTogXCJQZXJmb3JtIGNoZWNrLCBkb24ndCBjaGFuZ2UgYW55dGhpbmdcIlxuICAgIH0sXG4gICAgJ3VzZXJuYW1lJzoge1xuICAgICAgYWxpYXM6ICd1JyxcbiAgICAgIGRlZmF1bHQ6IGRlZmF1bHRzLnVzZXJuYW1lIHx8IHByb2Nlc3MuZW52LlVTRVIsXG4gICAgICBkZXNjcmliZTogJ1VzZXJuYW1lIHRvIHVzZSB3aGVuIGNvbm5lY3RpbmcgdG8gZGVwbG95bWVudCBzZXJ2ZXInXG4gICAgfSxcbiAgICAna2V5ZmlsZSc6IHtcbiAgICAgIGFsaWFzOiAnaycsXG4gICAgICBkZWZhdWx0OiBkZWZhdWx0cy5rZXlmaWxlLFxuICAgICAgZGVzY3JpYmU6ICdQYXRoIHRvIHByaXZhdGUga2V5J1xuICAgIH0sXG4gICAgJ3NlcnZlcic6IHtcbiAgICAgIGFsaWFzOiAncycsXG4gICAgICBkZWZhdWx0OiBkZWZhdWx0cy5zZXJ2ZXIsXG4gICAgICBkZXNjcmliZTogJ0Z1bGwgc2VydmVyIFVSTCdcbiAgICB9XG4gIH1cblxuICB5YXJnb25hdXRcbiAgICAuc3R5bGUoJ2N5YW4nKVxuICAgIC5zdHlsZSgneWVsbG93JywgJ3JlcXVpcmVkJylcbiAgICAuZXJyb3JzU3R5bGUoJ3JlZC5ib2xkJylcblxuICBjb25zdCB7dXNhZ2UsIGNsaUFyZ30gPSBvdXRwdXRTdHlsZXNcblxuICB5YXJnc1xuICAgIC5vcHRpb25zKGFyZ3MpXG4gICAgLnVzYWdlKGBcXG4ke3VzYWdlKCdVU0FHRScpfTogJDAgLWEgJHtjbGlBcmcoJ2FwcElkZW50aWZpZXInKX0gLXQgJHtjbGlBcmcoJ3RhcmdldCcpfVsgJHtjbGlBcmcoJ3RhcmdldCcpfSAuLi5dYClcbiAgICAuYWxpYXMoJ2hlbHAnLCAnaCcpXG4gICAgLmhlbHAoJ2hlbHAnKVxuICAgIC5leGFtcGxlKCckMCAtYSBkZWVwc2VhIC10IGNhbGxpc3RvJywgJ0RlcGxveSBhcHAgXCJkZWVwc2VhXCIgdG8gdGFyZ2V0IFwiY2FsbGlzdG9cIicpXG4gICAgLmV4YW1wbGUoJyQwIC1hIHBhc3NlcmJ5IC10IGFsbCAtdSBzb21lX3VzZXIgLWsgfi8uc3NoL2lkX3JzYS5zb21ldXNlciAtLWNoZWNrJywgJ1BlcmZvcm0gYSBtb2NrLWRlcGxveW1lbnQgb2YgXCJwYXNzZXJieVwiIHRvIGFsbCBhdmFpbGFibGUgdGFyZ2V0cywgY29ubmVjdGluZyBhcyB1c2VyIFwic29tZV91c2VyXCIsIHVzaW5nIHByaXZhdGUga2V5IGZpbGUgXCJ+Ly5zc2gvaWRfcnNhLnNvbWV1c2VyXCIuJylcblxuICBjb25zdCByYXcgPSB5YXJncy5hcmd2XG5cbiAgX29wdHMgPSB7fVxuXG4gIC8vIE9ubHkgZXhwb3J0IGZ1bGwgbmFtZXNcbiAgT2JqZWN0LmtleXMoYXJncykuZm9yRWFjaChrID0+IF9vcHRzWyBrIF0gPSByYXdbIGsgXSlcblxuICByZXR1cm4gX29wdHNcbn1cbiJdfQ==
'use strict'

import crypto from 'crypto'
import expandHomeDir from 'expand-home-dir'
import fs from 'fs'
import Promise from 'bluebird'
import ursa from 'ursa'
import Websocket from 'ws'

import output, { LEVEL_ERROR, LEVEL_OK, outputStyles } from 'output'

class WebsocketClient {
  constructor (opts) {
    this.opts = opts
  }

  connect () {
    return new Promise((resolve, reject) => {
      const {url} = this.opts

      this.socket = new Websocket(url)
      this.socket.on('open', () => resolve(this.socket))

      this.socket.on('message', (data) => {
        try {
          const {level, message, error} = JSON.parse(data)

          output(message, error ? LEVEL_ERROR : level, true)
        } catch (e) {
          output(`Failed to parse server response. Something weird might be happening. Error message: ${e.message}`, LEVEL_ERROR)
          output(`  Raw server response: ${data}`)
        }
      })

      this.socket.on('close', (code, message) => {
        if (code > 1000) {
          output(`Command failed with code ${outputStyles.error(code)}.`, LEVEL_ERROR)
        } else {
          output(`Command completed, closing connection to ${outputStyles.url(url)}.`, LEVEL_OK)
        }

        if (message) {
          output(`  Socket close message: ${message}`)
        }

        // if (code > 1000) {
        //    process.exit(1)
        // }
      })

      this.socket.on('error', err => reject(err))
    })
  }

  sendCommand ({ command, keyfile, payload, debug }) {
    const {username} = this.opts

    output(this.getInfoMessage(command, payload))

    const cryptData = this.getEncryptedCommand(keyfile, { command, payload })

    this.socket.send(JSON.stringify({ username, debug, cryptData }))
  }

  getEncryptedCommand (keyfile, commandSpec) {
    const algorithm = 'aes-256-ctr'
    const outputEncoding = 'base64'
    const privKey = ursa.createPrivateKey(fs.readFileSync(expandHomeDir(keyfile), { encoding: 'utf8' }))
    const secret = crypto.randomBytes(32).toString('hex')
    const cipher = crypto.createCipher(algorithm, secret)

    return {
      algorithm,
      outputEncoding,
      secret: privKey.privateEncrypt(secret),
      message: cipher.update(JSON.stringify(commandSpec), 'utf8', outputEncoding) + cipher.final(outputEncoding)
    }
  }

  getInfoMessage (command, payload) {
    const {username} = this.opts

    switch (command) {
      case 'deploy':
        const { app, targets } = payload
        return `Sending request to deploy ${outputStyles.app(app)} as user ${outputStyles.username(username)} to targets: ${targets.map(t => outputStyles.target(t)).join(', ')}.`

      case 'user':
        const { action, accountname } = payload
        const targetAccount = outputStyles.target(accountname)

        const msg = new Map([
          [ 'create', `to create user ${targetAccount}` ],
          [ 'add-pubkey', `add public key to account ${targetAccount}` ],
          [ 'remove-pubkey', `remove public key from account ${targetAccount}` ],
          [ 'remove', `remove account ${targetAccount}` ]
        ])

        return `Sending request to ${msg.get(action)}.`

      case 'user-list':
        return 'Sending request to retrieve user list.'

      default:
        return `[[ Somebody might want to implement an info message for command "${command}" ]]`
    }
  }
}

export default WebsocketClient

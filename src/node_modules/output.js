'use strict'

import chalk from 'chalk'
import stripAnsi from 'strip-ansi'
import {
  CATEGORY_INFO,
  MSG_LEVEL_DEBUG,
  MSG_LEVEL_ERROR,
  MSG_LEVEL_INFO,
  MSG_LEVEL_OK,
  MSG_LEVEL_RAW
} from 'handout-constants'

export const outputStyles = {
  headline: chalk.bold.yellow,
  url: chalk.yellow,
  target: chalk.cyan,
  error: chalk.bold.red,
  username: chalk.yellow,
  app: chalk.yellow,
  usage: chalk.bold.yellow,
  cliArg: chalk.cyan,
  [MSG_LEVEL_ERROR]: chalk.bold.red,
  [MSG_LEVEL_INFO]: chalk.bold.grey,
  [MSG_LEVEL_OK]: chalk.bold.green,
  [MSG_LEVEL_DEBUG]: chalk.bgYellow
}

// Utility stuff
const raw = msg => output(msg, MSG_LEVEL_RAW)
const newline = () => raw('')
const hr = () => raw(chalk.grey(new Array(80).join('-')))

function pad (str, max = 15, char = ' ') {
  const len = stripAnsi(str).length

  return len < max ? str + (new Array(max - len + 1)).join(char) : str
}

export default function output (message, level = MSG_LEVEL_INFO, fromRemote = false) {
  let prepend = ''

  if (level !== MSG_LEVEL_RAW) {
    prepend += `[${fromRemote ? 'server' : 'local'}:${outputStyles[ level ](level)}]`

    console.log(`${pad(prepend)} ${message}`)
  } else {
    console.log(message)
  }
}

export function outputTitle ({ version }) { // All of package.json passed in, using only version for now
  newline()
  hr()
  raw(outputStyles.headline('handout'))
  raw(`${outputStyles.headline('tailored apps')} backend deployment tool v${version}`)
  hr()
  newline()
}

/**
 * Processes raw data and generates output for server responses that require additional processing (i.e. those with MSG_LEVEL_PROCESS).
 *
 * @param wrapperObj object
 */
export function processResponse ({ category, data }) {
  // We only implement CATEGORY_INFO for now, can use a switch or a function map later
  if (category === CATEGORY_INFO) {
    processInfoResponse(data)
  } else {
    output(`Incorrect output processing category "${category}" returned from server.`, MSG_LEVEL_ERROR)
  }
}

function processInfoResponse ({ hosts, deployment, users, permissions }) {
  const { headline, target } = outputStyles

  const item = chalk.blue
  const granted = chalk.green
  const denied = chalk.red

  const indent = (str) => raw(`    ${str}`)
  const col = (left, right = '', width = 25) => indent(`${pad(left, width)}${right}`)
  const title = str => {
    hr()
    indent(headline(str.toUpperCase()))
    hr()
  }

  if (users) {
    title('Users')
    users.forEach(u => col(item(u)))
  }

  title('Permissions')
  Object.keys(permissions).forEach((p) => {
    col(item(p), permissions[p] ? granted('granted') : denied('denied'))
  })

  title('Targets')
  col('TARGET ID', 'HOSTNAME')
  Object.keys(hosts).forEach((hostId) => {
    const host = hosts[hostId]
    const isGroup = Array.isArray(host)
    const idOutput = (isGroup ? 'group: ' : '') + item(hostId)

    col(idOutput, isGroup ? host.join(', ') : host)
  })

  title('Deployment')
  col('APP', 'TARGETS')
  Object.keys(deployment).forEach((appId) => {
    const targets = deployment[appId]

    // Each applicable deployment target for the current app will be a property of the "targets" object, and the
    // property's value will be a boolean (true when deployment permission has been granted, false otherwise)
    col(
      item(appId),
      Object.keys(targets).map((target) => targets[target] ? granted(target) : denied(target)).join(', ')
    )
  })
}
